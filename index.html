<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Floating Sound Bubbles</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
    }
    #p5-container {
      position: fixed;
      inset: 0;
    }
    /*test4*/
    .info-overlay {
      position: fixed;
      left: 1rem;
      top: 1rem;
      z-index: 10;
      font-size: 0.9rem;
      color: #aaa;
      background: rgba(0,0,0,0.6);
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="info-overlay">
    Floating sound bubbles Â· click a bubble to expand / play, click again to collapse / stop.
  </div>
  <div id="p5-container"></div>

  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>

  <script>
    // ==============================
    // CONFIG
    // ==============================

    // CSV on GitHub (public repo)
    const CSV_URL =
      "https://raw.githubusercontent.com/fraloisio/sonic-runs-assets/refs/heads/main/records.csv";

    const REFRESH_INTERVAL_MS = 30_000;
    const BASE_RADIUS = 25;
    const EXPANDED_RADIUS = 120;
    const FADE_DURATION_MS = 700;

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    // ==============================
    // DATA STRUCTURES
    // ==============================

    let bubbles = [];
    let bubblesById = {};
    let pRef = null; // hold p5 instance so Bubble can load images

    class Bubble {
      constructor(record) {
        this.id = record.id;
        this.title = record.title || "Untitled";
        this.description = record.description || "";
        this.imageUrl = record.imageUrl || null;
        this.audioUrl = record.audioUrl || null;
        this.image = null;
        this.imageAlpha = 0;

        this.x = Math.random() * window.innerWidth;
        this.y = Math.random() * window.innerHeight;
        const speed = 0.3 + Math.random() * 0.4;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;

        this.radius = BASE_RADIUS;
        this.targetRadius = BASE_RADIUS;

        this.baseColor = [200, 200, 255];
        this.expanded = false;

        this.audio = null;
        this.fadeInterval = null;

        if (this.imageUrl) {
          this.loadAverageColorFromImage(this.imageUrl);
          this.loadImage(this.imageUrl);
        }
        if (this.audioUrl) {
          this.audio = new Audio(this.audioUrl);
          this.audio.loop = true;
          this.audio.volume = 0;
        }
      }

      loadAverageColorFromImage(url) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = url;
        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            const w = 16, h = 16;
            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, w, h);
            const data = ctx.getImageData(0, 0, w, h).data;
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < data.length; i += 4) {
              r += data[i];
              g += data[i + 1];
              b += data[i + 2];
              count++;
            }
            r = Math.floor(r / count);
            g = Math.floor(g / count);
            b = Math.floor(b / count);
            const factor = 0.7;
            this.baseColor = [
              Math.min(255, Math.floor(r * factor + 50)),
              Math.min(255, Math.floor(g * factor + 50)),
              Math.min(255, Math.floor(b * factor + 50)),
            ];
          } catch (e) {
            console.warn("Failed to sample image color", e);
          }
        };
        img.onerror = () => {
          console.warn("Could not load image for color", url);
        };
      }

      loadImage(url) {
        if (!pRef) return;
        this.image = null;
        this.imageAlpha = 0;
        pRef.loadImage(
          url,
          img => {
            this.image = img;
          },
          err => {
            console.warn("Could not load bubble image", url, err);
          }
        );
      }

      setExpanded(expanded) {
        this.expanded = expanded;
        this.targetRadius = expanded ? EXPANDED_RADIUS : BASE_RADIUS;
        this.targetImageAlpha = expanded ? 255 : 0;
        if (!this.audio) return;
        if (expanded) {
          this.fadeInAudio();
        } else {
          this.fadeOutAudio();
        }
      }

      fadeInAudio() {
        if (!this.audio) return;
        if (this.fadeInterval) clearInterval(this.fadeInterval);

        this.audio.volume = 0;
        this.audio.play().catch(err => console.warn("audio play error", err));

        const start = performance.now();
        this.fadeInterval = setInterval(() => {
          const t = Math.min(1, (performance.now() - start) / FADE_DURATION_MS);
          this.audio.volume = t;
          if (t >= 1) {
            clearInterval(this.fadeInterval);
            this.fadeInterval = null;
          }
        }, 40);
      }

      fadeOutAudio() {
        if (!this.audio) return;
        if (this.fadeInterval) clearInterval(this.fadeInterval);

        const startVol = this.audio.volume;
        const start = performance.now();
        this.fadeInterval = setInterval(() => {
          const t = Math.min(1, (performance.now() - start) / FADE_DURATION_MS);
          this.audio.volume = startVol * (1 - t);
          if (t >= 1) {
            clearInterval(this.fadeInterval);
            this.fadeInterval = null;
            this.audio.pause();
          }
        }, 40);
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;

        const margin = this.radius + 10;
        if (this.x < margin) { this.x = margin; this.vx *= -1; }
        if (this.x > window.innerWidth - margin) { this.x = window.innerWidth - margin; this.vx *= -1; }
        if (this.y < margin) { this.y = margin; this.vy *= -1; }
        if (this.y > window.innerHeight - margin) { this.y = window.innerHeight - margin; this.vy *= -1; }

        this.radius = lerp(this.radius, this.targetRadius, 0.1);
        this.imageAlpha = lerp(this.imageAlpha, this.expanded ? 255 : 0, 0.1);
      }

      draw(p) {
        const [r, g, b] = this.baseColor;

        p.noStroke();
        p.fill(r, g, b, this.expanded ? 80 : 40);
        p.circle(this.x, this.y, this.radius * 2.5);

        p.fill(r, g, b, this.expanded ? 230 : 180);
        p.circle(this.x, this.y, this.radius * 2);

        if (this.image && this.imageAlpha > 1 && this.expanded) {
          p.push();
          p.translate(this.x, this.y);
          p.tint(255, this.imageAlpha);
          const imgSize = this.radius * 2 * 0.95;
          const ctx = p.drawingContext;
          ctx.save();
          ctx.beginPath();
          ctx.arc(0, 0, imgSize / 2, 0, Math.PI * 2);
          ctx.clip();
          const iw = this.image.width;
          const ih = this.image.height;
          const scale = Math.max(imgSize / iw, imgSize / ih);
          const drawW = iw * scale;
          const drawH = ih * scale;
          p.image(this.image, -drawW / 2, -drawH / 2, drawW, drawH);
          ctx.restore();
          p.pop();
        }

        if (this.expanded) {
          p.fill(255);
          p.textAlign(p.CENTER, p.TOP);
          p.textSize(14);
          p.text(this.title, this.x, this.y + this.radius + 10);

          if (this.description) {
            p.textSize(11);
            p.fill(200);
            const maxWidth = 260;
            p.text(
              this.description,
              this.x - maxWidth / 2,
              this.y + this.radius + 28,
              maxWidth,
              200
            );
          }
        }
      }

      hitTest(px, py) {
        const dx = px - this.x;
        const dy = py - this.y;
        return dx * dx + dy * dy <= this.radius * this.radius;
      }
    }

    // ==============================
    // CSV FETCH + PARSE
    // ==============================

    function parseCSV(text) {
      const lines = [];
      let currentLine = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        if (ch === '"') {
          const next = text[i + 1];
          currentLine += ch;
          if (inQuotes && next === '"') {
            currentLine += next;
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (ch === "\n" && !inQuotes) {
          lines.push(currentLine.replace(/\r$/, ""));
          currentLine = "";
        } else {
          currentLine += ch;
        }
      }
      if (currentLine.trim() !== "") {
        lines.push(currentLine.replace(/\r$/, ""));
      }

      if (lines.length === 0) return [];

      const header = parseCSVRow(lines[0]).map(h => h.trim().toLowerCase());
      const rows = [];

      for (let i = 1; i < lines.length; i++) {
        if (!lines[i].trim()) continue;
        const cols = parseCSVRow(lines[i]);
        const rowObj = {};
        header.forEach((h, idx) => {
          rowObj[h] = cols[idx] !== undefined ? cols[idx] : "";
        });
        rows.push(rowObj);
      }
      return rows;
    }

    function parseCSVRow(line) {
      const result = [];
      let current = "";
      let inQuotes = false;

      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQuotes && line[i + 1] === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (ch === ',' && !inQuotes) {
          result.push(current);
          current = "";
        } else {
          current += ch;
        }
      }
      result.push(current);
      return result;
    }

    async function fetchRecords() {
      try {
        const res = await fetch(CSV_URL + "?t=" + Date.now());
        if (!res.ok) {
          console.error("Failed to fetch CSV", res.status);
          return;
        }
        const text = await res.text();
        const rows = parseCSV(text);

        const newRecordsById = {};

        rows.forEach(row => {
          const h = Object.keys(row).reduce((acc, k) => {
            acc[k.toLowerCase()] = row[k];
            return acc;
          }, {});

          let id = (h.id || "").trim();
          if (!id) return;
          if (!/^\d+/.test(id)) return;

          const title = (h.title || "").trim();

          const imageUrl = (h.image_url || "").trim();
          const audioUrl = (h.audio_url || "").trim();

          let descriptionParts = [];
          if (h.analysis && h.analysis.trim() !== "") {
            descriptionParts.push(h.analysis.trim());
          }
          if (h.long_prompt && h.long_prompt.trim() !== "") {
            descriptionParts.push(h.long_prompt.trim());
          }
          const description = descriptionParts.join("\n\n");

          newRecordsById[id] = {
            id,
            title,
            imageUrl,
            audioUrl,
            description
          };

          console.log("Loaded record:", id, { title, imageUrl, audioUrl });
        });

        syncBubblesWithRecords(newRecordsById);
      } catch (e) {
        console.error("Error fetching CSV", e);
      }
    }

    function syncBubblesWithRecords(recordsById) {
      bubbles = bubbles.filter(b => {
        if (!recordsById[b.id]) {
          if (b.audio) b.fadeOutAudio();
          delete bubblesById[b.id];
          return false;
        }
        return true;
      });

      for (const id in recordsById) {
        const rec = recordsById[id];
        if (bubblesById[id]) {
          const b = bubblesById[id];
          b.title = rec.title || b.title;
          b.description = rec.description || b.description;

          if (rec.imageUrl && rec.imageUrl !== b.imageUrl) {
            b.imageUrl = rec.imageUrl;
            b.loadAverageColorFromImage(rec.imageUrl);
            b.loadImage(rec.imageUrl);
          }
          if (rec.audioUrl && rec.audioUrl !== b.audioUrl) {
            b.audioUrl = rec.audioUrl;
            if (b.audio) b.audio.pause();
            b.audio = new Audio(rec.audioUrl);
            b.audio.loop = true;
            b.audio.volume = 0;
          }
        } else {
          const bubble = new Bubble(rec);
          bubbles.push(bubble);
          bubblesById[id] = bubble;
        }
      }

      console.log(`Synced bubbles: ${bubbles.length}`);
    }

    // ==============================
    // p5.js sketch
    // ==============================

    new p5(p => {
      p.setup = () => {
        pRef = p;
        const canvas = p.createCanvas(window.innerWidth, window.innerHeight);
        canvas.parent("p5-container");
        p.frameRate(60);
        fetchRecords();
        setInterval(fetchRecords, REFRESH_INTERVAL_MS);
      };

      p.windowResized = () => {
        p.resizeCanvas(window.innerWidth, window.innerHeight);
      };

      p.draw = () => {
        p.background(0);
        for (const b of bubbles) {
          b.update();
          b.draw(p);
        }
      };

      p.mousePressed = () => {
        for (let i = bubbles.length - 1; i >= 0; i--) {
          const b = bubbles[i];
          if (b.hitTest(p.mouseX, p.mouseY)) {
            b.setExpanded(!b.expanded);
            break;
          }
        }
      };
    });
  </script>
</body>
</html>
